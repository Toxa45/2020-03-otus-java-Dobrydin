package ru.otus.jdbc.mapper.impl;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;
import lombok.Getter;
import lombok.SneakyThrows;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import ru.otus.jdbc.DbExecutorImpl;
import ru.otus.jdbc.exception.MapperException;
import ru.otus.jdbc.exception.MetadataException;
import ru.otus.jdbc.mapper.EntityClassMetaData;
import ru.otus.jdbc.mapper.EntitySQLMetaData;
import ru.otus.jdbc.mapper.JdbcMapper;
import ru.otus.jdbc.sessionmanager.SessionManagerJdbc;

public class JdbcMapperImpl<T, ID> implements JdbcMapper<T, ID> {

  private static final Logger logger = LoggerFactory.getLogger(JdbcMapperImpl.class);

  private final EntityClassMetaData<T> entityClassMetaData;
  private final EntitySQLMetaData entitySQLMetaData;
  @Getter
  private final SessionManagerJdbc sessionManager;
  private final DbExecutorImpl<T> dbExecutor;

  public JdbcMapperImpl(Class<T> clazz, SessionManagerJdbc sessionManager,
      DbExecutorImpl<T> dbExecutor) {
    this.entityClassMetaData = new EntityClassMetaDataImpl<T>(clazz);
    this.entitySQLMetaData = new EntitySQLMetaDataImpl(this.entityClassMetaData);
    this.sessionManager = sessionManager;
    this.dbExecutor = dbExecutor;
  }

  @Override
  public ID insert(T objectData) {
    try {
      ID id = (ID) dbExecutor.executeInsert(getConnection(), entitySQLMetaData.getInsertSql(),
          getFieldValues(objectData,
              entityClassMetaData.isAutogeneratedIdField()
                  ? entityClassMetaData.getFieldsWithoutId()
                  : entityClassMetaData.getAllFields())
      );
      updateObjectId(objectData, id);
      return id;
    } catch (Exception e) {
      throw new MapperException(e);
    }
  }

  private ID update(T objectData) {
    try {
      ID objectId = getObjectId(objectData);
      if (objectId == null) {
        throw new MetadataException("Error update object " + objectData + ", object not save db");
      } else {
        List<Object> params = getFieldValues(objectData, entityClassMetaData.getFieldsWithoutId());
        params.add(objectId);
        dbExecutor.executeInsert(getConnection(), entitySQLMetaData.getUpdateSql(), params);
      }
      return objectId;
    } catch (Exception e) {
      throw new MapperException(e);
    }
  }

  @Override
  public ID insertOrUpdate(T objectData) {
    ID objectId = getObjectId(objectData);
    if ( objectId == null || !existsById(objectId)) {
      return insert(objectData);
    } else {
      return update(objectData);
    }
  }

  @SneakyThrows
  private boolean existsById(ID id) {
    return dbExecutor.executeSelect(getConnection(), entitySQLMetaData.getSelectByIdSql(), id,
        rs -> {
          try {
            return rs.next() ? (T) new Object() : null;
          } catch (SQLException e) {
            throw new MapperException(e);
          }
        }).isPresent();
  }

  @Override
  public List<T> findAll() {
    try {
      Object[] param = new Object[0];
      return dbExecutor.executeSelect(getConnection(), entitySQLMetaData.getSelectAllSql(), param ,
          this::mapResultSetToObject);
    } catch (Exception e) {
      logger.error(e.getMessage(), e);
      throw new MetadataException(e);
    }
  }

  @Override
  public Optional<T> findById(ID id) {
    try {
      return dbExecutor.executeSelect(getConnection(), entitySQLMetaData.getSelectByIdSql(), id,
          this::mapResultSetToObject);
    } catch (Exception e) {
      logger.error(e.getMessage(), e);
      throw new MetadataException(e);
    }
  }

  private T mapResultSetToObject(ResultSet resultSet) {
    try {
      if (!resultSet.next()) {
        return null;
      }
    } catch (SQLException throwables) {
      throwables.printStackTrace();
    }

    try {
      Constructor<T> constructor = entityClassMetaData.getConstructor();
      Class<?>[] parameterTypes = constructor.getParameterTypes();
      int parameterCount = parameterTypes.length;
      T objectNew;
      if (parameterCount > 0) {
        Object[] param = new Object[parameterCount];
        for (int indexParam = 0; indexParam < parameterCount; indexParam++) {
          if (parameterTypes[indexParam].isPrimitive()) {
            param[indexParam] = 0;
          } else {
            param[indexParam] = null;
          }
        }
        objectNew = constructor.newInstance(param);
      } else {
        objectNew = constructor.newInstance();
      }
      entityClassMetaData.getAllFields()
          .forEach(f -> {
            try {
              var value = resultSet.getObject(f.getName());
              f.set(objectNew, value);
            } catch (SQLException throwables) {
              throwables.printStackTrace();
            } catch (IllegalAccessException e) {
              e.printStackTrace();
            }
          });
      return objectNew;
    } catch (ReflectiveOperationException e) {
      throw new MapperException("Error map ResultSet to object", e);
    }
  }

  @SneakyThrows
  private ID getObjectId(T objectData) {
    return (ID) entityClassMetaData.getIdField().get(objectData);
  }

  @SneakyThrows
  private void updateObjectId(T objectData, ID id) {
    entityClassMetaData.getIdField().set(objectData, id);
  }

  private List<Object> getFieldValues(T object, List<Field> fields) {
    return fields.stream()
        .map(field -> {
          try {
            return field.get(object);
          } catch (IllegalAccessException e) {
            throw new MetadataException(
                String.format("Error getting field %s value", field.getName()), e);
          }
        })
        .collect(Collectors.toList());
  }

  private Connection getConnection() {
    return sessionManager.getCurrentSession().getConnection();
  }

}
